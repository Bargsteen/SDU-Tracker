//
//  PersistenceHandler.swift
//  ActivityTrackerSDU
//
//  Created by Kasper Dissing Bargsteen on 16/09/2018.
//

import Foundation
import SQLite


class PersistenceHandler: PersistenceHandlerProtocol {
    
    // Dependencies
    private let logger: LoggerProtocol
    private let settings: SettingsProtocol
    
    private let db: Connection
    
    // Tables
    private let appUsageTable = Table("app_usages")
    private let deviceUsageTable = Table ("device_usages")
    
    // Common columns
    private let id = Expression<Int64>("id")
    private let participantIdentifier = Expression<String>("participant_identifier")
    private let userCount = Expression<Int>("user_count")
    private let timeStamp = Expression<Date>("time_stamp")
    
    // AppUsage specific columns
    private let package = Expression<String>("package")
    private let duration = Expression<Int>("duration")

    // DeviceUsage specific columns
    private let eventType = Expression<Int>("event_type")
    
    init(logger: LoggerProtocol, settings:SettingsProtocol, useInMemoryDb: Bool = false) {
        self.logger = logger
        self.settings = settings
        
        self.db = PersistenceHandler.getDatabaseConnection(useInMemoryDb: useInMemoryDb)
        
        ensureTablesAreCreated()
    }
    
   func save<T:Usage>(_ usage: T){
        do {
            switch(usage) {
            case let appUsage as AppUsage:
                try db.run(appUsageTable.insert(
                    participantIdentifier <- appUsage.participantIdentifier,
                    userCount <- appUsage.userCount,
                    timeStamp <- appUsage.timeStamp,
                    package <- appUsage.package,
                    duration <- appUsage.duration))
                return
            case let deviceUsage as DeviceUsage:
                try db.run(deviceUsageTable.insert(
                    participantIdentifier <- deviceUsage.participantIdentifier,
                    userCount <- deviceUsage.userCount,
                    timeStamp <- deviceUsage.timeStamp,
                    eventType <- deviceUsage.eventType))
                return
            default:
                return // Never happens
            }
        } catch {
            logger.logError("Persistence save: \(error)")
        }
    }
    
    func delete<T: Usage>(_ usage: T){
        do {
            // Id is always set, when trying to delete, as it is generated by the db on insert.
            let usageId = usage.id!
            
            switch(usage){
            case is AppUsage:
                let appUsageFromDb = appUsageTable.filter(id == usageId)
                try db.run(appUsageFromDb.delete())
            case is DeviceUsage:
                let deviceUsageFromDb = deviceUsageTable.filter(id == usageId)
                try db.run(deviceUsageFromDb.delete())
            default:
                return
            }
        } catch {
            logger.logError("Persistence delete: \(error)")
        }
    }
    
    
    func fetchDeviceUsages(upTo: Int) -> [DeviceUsage] {
        do {
            return Array(try db.prepare(deviceUsageTable.order(timeStamp).limit(upTo))).map { usageFromDb in
                DeviceUsage(participantIdentifier: usageFromDb[participantIdentifier], deviceModelName: settings.deviceModelName,
                                                      timeStamp: usageFromDb[timeStamp], userCount: usageFromDb[userCount],
                                                      eventType: EventType(rawValue: usageFromDb[eventType])!, id: usageFromDb[id])
            }
        } catch {
            logger.logError("Persistence fetchDeviceUsages: \(error)")
        }
        return []
    }
    
    
    func fetchAppUsages(upTo: Int) -> [AppUsage] {
        do {            
            return Array(try db.prepare(appUsageTable.order(timeStamp).limit(upTo))).map { usageFromDb in
                AppUsage(participantIdentifier: usageFromDb[participantIdentifier], deviceModelName: settings.deviceModelName,
                         timeStamp: usageFromDb[timeStamp], userCount: usageFromDb[userCount], package: usageFromDb[package],
                         duration: usageFromDb[duration], id: usageFromDb[id])
            }
        } catch {
            logger.logError("Persistence fetchAllAppUsages: \(error)")
        }
        return []
    }
    
    private static func getDatabaseConnection(useInMemoryDb: Bool) -> Connection {
        if(useInMemoryDb) {
            do {
                return try Connection(.inMemory)
            } catch {
                fatalError("Could not connect to in memory database: \(error)")
            }
        } else {
            let applicationSupportPath = NSSearchPathForDirectoriesInDomains(
                .applicationSupportDirectory, .userDomainMask, true
                ).first!
            
            do {
                // create parent directory iff it doesnâ€™t exist
                try FileManager.default.createDirectory(
                    atPath: applicationSupportPath, withIntermediateDirectories: true, attributes: nil
                )
                return try Connection("\(applicationSupportPath)/db.sqlite3")
            } catch {
                fatalError("Could not connect to database: \(error)")
            }
        }
    }
    
    
    private func ensureTablesAreCreated() {
        do {
            try db.run(appUsageTable.create(ifNotExists: true) { t in
                t.column(id, primaryKey: .autoincrement)
                t.column(participantIdentifier)
                t.column(userCount)
                t.column(timeStamp)
                
                t.column(package)
                t.column(duration)
            })
            
            try db.run(deviceUsageTable.create(ifNotExists: true) { t in
                t.column(id, primaryKey: .autoincrement)
                t.column(participantIdentifier)
                t.column(userCount)
                t.column(timeStamp)
                
                t.column(eventType)
            })
        } catch {
            fatalError("Could not create tables in database: \(error)")
        }
    }
}
